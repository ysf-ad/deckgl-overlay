"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StreamingXMLParser = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _sax = require("../../sax-ts/sax");
class StreamingXMLParser {
  constructor(options) {
    (0, _defineProperty2.default)(this, "parser", void 0);
    (0, _defineProperty2.default)(this, "result", undefined);
    (0, _defineProperty2.default)(this, "previousStates", []);
    (0, _defineProperty2.default)(this, "currentState", Object.freeze({
      container: [],
      key: null
    }));
    this.reset();
    this.parser = new _sax.SAXParser({
      onready: () => {
        this.previousStates.length = 0;
        this.currentState.container.length = 0;
      },
      onopentag: _ref => {
        let {
          name,
          attributes,
          isSelfClosing
        } = _ref;
        this._openObject({});
        if (typeof name !== 'undefined') {
          this.parser.emit('onkey', name);
        }
      },
      onkey: name => {
        this.currentState.key = name;
      },
      onclosetag: () => {
        this._closeObject();
      },
      onopenarray: () => {
        this._openArray();
      },
      onclosearray: () => {
        this._closeArray();
      },
      ontext: value => {
        this._pushOrSet(value);
      },
      onerror: error => {
        throw error;
      },
      onend: () => {
        this.result = this.currentState.container.pop();
      },
      ...options
    });
  }
  reset() {
    this.result = undefined;
    this.previousStates = [];
    this.currentState = Object.freeze({
      container: [],
      key: null
    });
  }
  write(chunk) {
    this.parser.write(chunk);
  }
  close() {
    this.parser.close();
  }
  _pushOrSet(value) {
    const {
      container,
      key
    } = this.currentState;
    if (key !== null) {
      container[key] = value;
      this.currentState.key = null;
    } else if (Array.isArray(container)) {
      container.push(value);
    } else if (container) {}
  }
  _openArray() {
    let newContainer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    this._pushOrSet(newContainer);
    this.previousStates.push(this.currentState);
    this.currentState = {
      container: newContainer,
      isArray: true,
      key: null
    };
  }
  _closeArray() {
    this.currentState = this.previousStates.pop();
  }
  _openObject() {
    let newContainer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this._pushOrSet(newContainer);
    this.previousStates.push(this.currentState);
    this.currentState = {
      container: newContainer,
      isArray: false,
      key: null
    };
  }
  _closeObject() {
    this.currentState = this.previousStates.pop();
  }
}
exports.StreamingXMLParser = StreamingXMLParser;
//# sourceMappingURL=streaming-xml-parser.js.map