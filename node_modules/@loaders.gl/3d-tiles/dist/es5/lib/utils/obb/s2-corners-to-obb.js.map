{"version":3,"file":"s2-corners-to-obb.js","names":["_core","require","_culling","_index","_geospatial","convertS2BoundingVolumetoOBB","s2VolumeInfo","token","heightInfo","minimumHeight","maximumHeight","corners","getS2OrientedBoundingBoxCornerPoints","center","getS2LngLat","centerLng","centerLat","point","Ellipsoid","WGS84","cartographicToCartesian","centerPointAdditional","Vector3","push","obb","makeOrientedBoundingBoxFromPoints","box","halfAxes"],"sources":["../../../../../src/lib/utils/obb/s2-corners-to-obb.ts"],"sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {OrientedBoundingBox, makeOrientedBoundingBoxFromPoints} from '@math.gl/culling';\n\nimport type {S2HeightInfo} from '../../utils/s2/index';\nimport {getS2OrientedBoundingBoxCornerPoints} from '../../utils/s2/index';\n\nimport {getS2LngLat} from '../../utils/s2/index';\nimport {Ellipsoid} from '@math.gl/geospatial';\n\nexport type S2VolumeInfo = {\n  /** S2 key or token */\n  token: string;\n  /** minimum height in meters */\n  minimumHeight: number;\n  /** maximum height in meters */\n  maximumHeight: number;\n};\n\n/**\n * Converts S2VolumeInfo to OrientedBoundingBox\n * @param {S2VolumeInfo} s2VolumeInfo - s2 volume to convert\n * @returns Oriented Bounding Box of type Box\n */\nexport function convertS2BoundingVolumetoOBB(s2VolumeInfo: S2VolumeInfo): number[] {\n  const token: string = s2VolumeInfo.token;\n  const heightInfo: S2HeightInfo = {\n    minimumHeight: s2VolumeInfo.minimumHeight,\n    maximumHeight: s2VolumeInfo.maximumHeight\n  };\n\n  const corners: Vector3[] = getS2OrientedBoundingBoxCornerPoints(token, heightInfo);\n\n  // Add a point that doesn't allow the box dive under the Earth\n\n  const center = getS2LngLat(token);\n  const centerLng: number = center[0];\n  const centerLat: number = center[1];\n  const point = Ellipsoid.WGS84.cartographicToCartesian([\n    centerLng,\n    centerLat,\n    heightInfo.maximumHeight\n  ]);\n  const centerPointAdditional = new Vector3(point[0], point[1], point[2]);\n  corners.push(centerPointAdditional);\n\n  // corners should be an array of Vector3 (XYZ)\n  const obb: OrientedBoundingBox = makeOrientedBoundingBoxFromPoints(corners);\n  const box: number[] = [...obb.center, ...obb.halfAxes];\n\n  return box;\n}\n"],"mappings":";;;;;;AAAA,IAAAA,KAAA,GAAAC,OAAA;AACA,IAAAC,QAAA,GAAAD,OAAA;AAGA,IAAAE,MAAA,GAAAF,OAAA;AAGA,IAAAG,WAAA,GAAAH,OAAA;AAgBO,SAASI,4BAA4BA,CAACC,YAA0B,EAAY;EACjF,MAAMC,KAAa,GAAGD,YAAY,CAACC,KAAK;EACxC,MAAMC,UAAwB,GAAG;IAC/BC,aAAa,EAAEH,YAAY,CAACG,aAAa;IACzCC,aAAa,EAAEJ,YAAY,CAACI;EAC9B,CAAC;EAED,MAAMC,OAAkB,GAAG,IAAAC,2CAAoC,EAACL,KAAK,EAAEC,UAAU,CAAC;EAIlF,MAAMK,MAAM,GAAG,IAAAC,kBAAW,EAACP,KAAK,CAAC;EACjC,MAAMQ,SAAiB,GAAGF,MAAM,CAAC,CAAC,CAAC;EACnC,MAAMG,SAAiB,GAAGH,MAAM,CAAC,CAAC,CAAC;EACnC,MAAMI,KAAK,GAAGC,qBAAS,CAACC,KAAK,CAACC,uBAAuB,CAAC,CACpDL,SAAS,EACTC,SAAS,EACTR,UAAU,CAACE,aAAa,CACzB,CAAC;EACF,MAAMW,qBAAqB,GAAG,IAAIC,aAAO,CAACL,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;EACvEN,OAAO,CAACY,IAAI,CAACF,qBAAqB,CAAC;EAGnC,MAAMG,GAAwB,GAAG,IAAAC,0CAAiC,EAACd,OAAO,CAAC;EAC3E,MAAMe,GAAa,GAAG,CAAC,GAAGF,GAAG,CAACX,MAAM,EAAE,GAAGW,GAAG,CAACG,QAAQ,CAAC;EAEtD,OAAOD,GAAG;AACZ"}