{"version":3,"file":"parse-3d-tile-point-cloud.js","names":["_draco","require","_math","_core","_tile3dFeatureTable","_interopRequireDefault","_tile3dBatchTable","_parse3dTileHeader","_parse3dTileTables","_normalize3dTileColors","_normalize3dTileNormals","_normalize3dTilePositions","parsePointCloud3DTile","tile","arrayBuffer","byteOffset","options","context","parse3DTileHeaderSync","parse3DTileTablesHeaderSync","parse3DTileTablesSync","initializeTile","featureTable","batchTable","parsePointCloudTables","parseDraco","parsePositions","parseColors","parseNormals","attributes","positions","colors","normals","batchIds","isQuantized","isTranslucent","isRGB565","isOctEncoded16P","Tile3DFeatureTable","featureTableJson","featureTableBinary","pointsLength","getGlobalProperty","Number","isFinite","Error","featuresLength","pointCount","rtcCenter","GL","FLOAT","parseBatchIds","hasProperty","getPropertyArray","UNSIGNED_SHORT","quantizedRange","quantizedVolumeScale","quantizedVolumeOffset","normalize3DTilePositionAttribute","UNSIGNED_BYTE","normalize3DTileColorAttribute","constantRGBA","normalize3DTileNormalAttribute","batchFeatureLength","batchTableJson","batchTableBinary","Tile3DBatchTable","dracoBuffer","dracoFeatureTableProperties","dracoBatchTableProperties","batchTableDraco","extensions","properties","featureTableDraco","getExtension","dracoByteOffset","dracoByteLength","byteLength","slice","hasPositions","POSITION","hasColors","RGB","RGBA","hasNormals","NORMAL","hasBatchIds","BATCH_ID","dracoData","buffer","featureTableProperties","batchTableProperties","dequantizeInShader","loadDraco","parse","dracoOptions","draco","extraAttributes","data","DracoLoader","decodedPositions","value","decodedColors","COLOR_0","decodedNormals","decodedBatchIds","isQuantizedDraco","quantization","isOctEncodedDraco","range","Vector3","minValues","quantizationBits","octEncodedRange","batchTableAttributes","attributeName","Object","keys","toLowerCase","undefined"],"sources":["../../../../src/lib/parsers/parse-3d-tile-point-cloud.ts"],"sourcesContent":["// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {GL} from '@loaders.gl/math';\nimport {Vector3} from '@math.gl/core';\n\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {normalize3DTileColorAttribute} from './helpers/normalize-3d-tile-colors';\nimport {normalize3DTileNormalAttribute} from './helpers/normalize-3d-tile-normals';\nimport {normalize3DTilePositionAttribute} from './helpers/normalize-3d-tile-positions';\n\nexport async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  initializeTile(tile);\n\n  const {featureTable, batchTable} = parsePointCloudTables(tile);\n\n  await parseDraco(tile, featureTable, batchTable, options, context);\n\n  parsePositions(tile, featureTable, options);\n  parseColors(tile, featureTable, batchTable);\n  parseNormals(tile, featureTable);\n\n  return byteOffset;\n}\n\nfunction initializeTile(tile) {\n  // Initialize point cloud tile defaults\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\n\nfunction parsePointCloudTables(tile) {\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n  featureTable.featuresLength = pointsLength;\n\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  const batchTable = parseBatchIds(tile, featureTable);\n\n  return {featureTable, batchTable};\n}\n\nfunction parsePositions(tile, featureTable, options) {\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n\nfunction parseColors(tile, featureTable, batchTable) {\n  if (!tile.attributes.colors) {\n    let colors = null;\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\n\nfunction parseNormals(tile, featureTable) {\n  if (!tile.attributes.normals) {\n    let normals = null;\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\n\nfunction parseBatchIds(tile, featureTable) {\n  let batchTable: Tile3DBatchTable | null = null;\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n\n    if (tile.batchIds) {\n      const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n      const {batchTableJson, batchTableBinary} = tile;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n  return batchTable;\n}\n\n// eslint-disable-next-line complexity\nasync function parseDraco(tile, featureTable, batchTable, options, context) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const batchTableDraco =\n    tile.batchTableJson &&\n    tile.batchTableJson.extensions &&\n    tile.batchTableJson.extensions['3DTILES_draco_point_compression'];\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n\n    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n    tile.hasColors =\n      Number.isFinite(dracoFeatureTableProperties.RGB) ||\n      Number.isFinite(dracoFeatureTableProperties.RGBA);\n    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n  }\n\n  if (!dracoBuffer) {\n    return true;\n  }\n\n  const dracoData = {\n    buffer: dracoBuffer,\n    properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n    featureTableProperties: dracoFeatureTableProperties,\n    batchTableProperties: dracoBatchTableProperties,\n    dequantizeInShader: false\n  };\n\n  return await loadDraco(tile, dracoData, options, context);\n}\n\n// eslint-disable-next-line complexity, max-statements\nexport async function loadDraco(tile, dracoData, options, context) {\n  const {parse} = context;\n  const dracoOptions = {\n    ...options,\n    draco: {\n      ...options.draco,\n      extraAttributes: dracoData.batchTableProperties || {}\n    }\n  };\n\n  // The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n\n  const data = await parse(dracoData.buffer, DracoLoader, dracoOptions);\n\n  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n  if (isQuantizedDraco) {\n    // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n    // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n    const quantization = data.POSITION.data.quantization;\n    const range = quantization.range;\n    tile.quantizedVolumeScale = new Vector3(range, range, range);\n    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n    tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n    tile.isQuantizedDraco = true;\n  }\n  if (isOctEncodedDraco) {\n    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n    tile.isOctEncodedDraco = true;\n  }\n\n  // Extra batch table attributes\n  const batchTableAttributes = {};\n  if (dracoData.batchTableProperties) {\n    for (const attributeName of Object.keys(dracoData.batchTableProperties)) {\n      if (data.attributes[attributeName] && data.attributes[attributeName].value) {\n        batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;\n      }\n    }\n  }\n\n  tile.attributes = {\n    positions: decodedPositions,\n    colors: normalize3DTileColorAttribute(tile, decodedColors, undefined),\n    normals: decodedNormals,\n    batchIds: decodedBatchIds,\n    ...batchTableAttributes\n  };\n}\n\n// TODO - this is the remaining code from Cesium's parser\n/*\n  const batchTable = new Tile3DBatchTable(tile);\n\n  // parseDracoBuffer(tile, featureTable, batchTable);\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n/*\n\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasPropertry('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (!tile.attributes.normals) {\n    if (featureTable.getPropertry('NORMAL')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.getProperty('NORMAL_OCT16P')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n\n  if (!tile.batchIds) {\n    if (featureTable.hasProperty('BATCH_ID')) {\n      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n\n  if (featureTable.getPropertry('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n\n  if (tile.batchIds) {\n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    if (!defined(batchLength)) {\n      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  tile.draco = draco;\n}\n\n// Separate parsing and decoding of Draco\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\n/*\nfunction decodeDraco(tile, context) {\n  if (tile.decodingState === DECODING_STATE.READY) {\n    return false;\n  }\n  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {\n    var parsedContent = tile._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      tile.decodingState = DECODING_STATE.DECODING;\n      decodePromise.then(function(result) {\n        tile.decodingState = DECODING_STATE.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          tile._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          tile._isOctEncodedDraco = true;\n        }\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray : property.array,\n              componentCount : property.data.componentsPerAttribute\n            };\n          }\n        }\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function(error) {\n        tile.decodingState = DECODING_STATE.FAILED;\n        tile._readyPromise.reject(error);\n      });\n    }\n  }\n  return true;\n}\n*/\n"],"mappings":"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"}