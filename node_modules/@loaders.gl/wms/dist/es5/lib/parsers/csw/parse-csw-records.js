"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseCSWRecords = parseCSWRecords;
exports.renameXMLTags = renameXMLTags;
var _xml = require("@loaders.gl/xml");
var _parseExceptionReport = require("./parse-exception-report");
function parseCSWRecords(text, options) {
  const parsedXML = _xml.XMLLoader.parseTextSync(text, {
    ...options,
    xml: {
      ...(options === null || options === void 0 ? void 0 : options.xml),
      removeNSPrefix: true,
      uncapitalizeKeys: true,
      arrayPaths: []
    },
    _fastXML: {
      ...(options === null || options === void 0 ? void 0 : options._fastXML),
      parseAttributeValue: true
    }
  });
  (0, _parseExceptionReport.parseExceptionReport)(parsedXML);
  const xmlRecords = parsedXML.getRecordsResponse;
  const elementSet = xmlRecords.searchResults.elementSet;
  const recordsFieldName = "".concat(elementSet, "Record");
  xmlRecords.records = xmlRecords.searchResults[recordsFieldName];
  delete xmlRecords.searchResults[recordsFieldName];
  (0, _xml.convertXMLFieldToArrayInPlace)(xmlRecords, 'records');
  for (const record of xmlRecords.records) {
    record.boundingBoxes = record.boundingBox;
    delete record.boundingBox;
    (0, _xml.convertXMLFieldToArrayInPlace)(record, 'boundingBoxes');
    for (const boundingBox of record.boundingBoxes) {
      boundingBox.value = [boundingBox.upperCorner[0], boundingBox.upperCorner[1], boundingBox.lowerCorner[0], boundingBox.lowerCorner[1]];
      delete boundingBox.upperCorner;
      delete boundingBox.lowerCorner;
    }
  }
  return xmlRecords;
}
function renameXMLTags(xml, renameKeys) {
  for (const [oldKey, newKey] of Object.entries(renameKeys)) {
    xml[newKey] = xml[oldKey];
    delete xml[oldKey];
  }
}
//# sourceMappingURL=parse-csw-records.js.map