{"version":3,"file":"parse-gml.js","names":["_xml","require","_deepStrictEqual","_rewind","_interopRequireDefault","noTransform","_len","arguments","length","coords","Array","_key","parseGML","text","options","parsedXML","XMLLoader","parseTextSync","transformCoords","stride","context","createChildContext","parseGMLToGeometry","inputXML","childContext","geometry","name","xml","getFirstKeyValue","type","coordinates","parseLinearRingOrLineString","parsePolygonOrRectangle","parseSurface","parseMultiSurface","rewind","mutate","parseCoords","s","srsDimension","replace","trim","split","Error","concat","points","i","_options$transformCoo","point","slice","map","parseFloat","push","call","parsePosList","textOf","parsePos","parsePoint","pos","findIn","posList","childName","childXML","Object","entries","parseCurveSegments","points2","end","start","deepStrictEqual","shift","parseRing","lineString","segments","parseExteriorOrInterior","linearRing","ring","exterior","pointLists","patches","polygons","parseCompositeSurface","c2Name","c2Xml","el","surfaceMembers","polygons2","polygons3","parseSurfaceMember","polygonXML","surfaceMemberXML","childXml","root","_len2","tags","_key2","tag","child","object","key","value","srsDimensionAttribute","attributes","parseInt","Number","isNaN","create"],"sources":["../../../../../src/lib/parsers/gml/parse-gml.ts"],"sourcesContent":["// loaders.gl, MIT license\n\n// Forked from https://github.com/derhuerst/parse-gml-polygon/blob/master/index.js\n// under ISC license\n\n/* eslint-disable no-continue, default-case */\n\nimport type {\n  // GeoJSON,\n  // Feature,\n  // FeatureCollection,\n  Geometry,\n  Position\n  // GeoJsonProperties,\n  // Point,\n  // MultiPoint,\n  // LineString,\n  // MultiLineString,\n  // Polygon,\n  // MultiPolygon,\n  // GeometryCollection\n} from '@loaders.gl/schema';\n\nimport {XMLLoader} from '@loaders.gl/xml';\nimport {deepStrictEqual} from './deep-strict-equal';\nimport rewind from '@turf/rewind';\n\nfunction noTransform(...coords) {\n  return coords;\n}\n\nexport type ParseGMLOptions = {\n  transformCoords?: Function;\n  stride?: 2 | 3 | 4;\n};\n\nexport type ParseGMLContext = {\n  srsDimension?: number;\n  [key: string]: any;\n};\n\n/**\n * Parses a typed data structure from raw XML for GML features\n * @note Error handlings is fairly weak\n */\nexport function parseGML(text: string, options) {\n  // GeoJSON | null {\n  const parsedXML = XMLLoader.parseTextSync(text, options);\n\n  options = {transformCoords: noTransform, stride: 2, ...options};\n  const context = createChildContext(parsedXML, options, {});\n\n  return parseGMLToGeometry(parsedXML, options, context);\n}\n\n/** Parse a GeoJSON geometry from GML XML */\nexport function parseGMLToGeometry(\n  inputXML: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Geometry | null {\n  const childContext = createChildContext(inputXML, options, context);\n\n  let geometry: Geometry | null = null;\n\n  const [name, xml] = getFirstKeyValue(inputXML);\n\n  switch (name) {\n    // case 'gml:MultiPoint':\n    //   geometry = {\n    //     type: 'MultiPoint',\n    //     coordinates: parseMultiPoint(xml, options, childContext)\n    //   };\n    //   break;\n\n    case 'gml:LineString':\n      geometry = {\n        type: 'LineString',\n        coordinates: parseLinearRingOrLineString(xml, options, childContext)\n      };\n      break;\n\n      // case 'gml:MultiLineString':\n      //   geometry = {\n      //     type: 'MultiLineString',\n      //     coordinates: parseMultiLineString(xml, options, childContext)\n      //   };\n      //   break;\n\n    case 'gml:Polygon':\n    case 'gml:Rectangle':\n      geometry = {\n        type: 'Polygon',\n        coordinates: parsePolygonOrRectangle(xml, options, childContext)\n      };\n      break;\n    case 'gml:Surface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseSurface(xml, options, childContext)\n      };\n      break;\n    case 'gml:MultiSurface':\n      geometry = {\n        type: 'MultiPolygon',\n        coordinates: parseMultiSurface(xml, options, childContext)\n      };\n      break;\n\n    default:\n      return null;\n  }\n\n  // todo\n  return rewind(geometry, {mutate: true});\n}\n\n/** Parse a list of coordinates from a string */\nfunction parseCoords(s: string, options: ParseGMLOptions, context: ParseGMLContext): Position[] {\n  const stride = context.srsDimension || options.stride || 2;\n\n  // Handle white space\n  const coords = s.replace(/\\s+/g, ' ').trim().split(' ');\n\n  if (coords.length === 0 || coords.length % stride !== 0) {\n    throw new Error(`invalid coordinates list (stride ${stride})`);\n  }\n\n  const points: Position[] = [];\n  for (let i = 0; i < coords.length - 1; i += stride) {\n    const point = coords.slice(i, i + stride).map(parseFloat);\n    points.push(options.transformCoords?.(...point) || point);\n  }\n\n  return points;\n}\n\nexport function parsePosList(xml: any, options: ParseGMLOptions, context: ParseGMLContext) {\n  const childContext = createChildContext(xml, options, context);\n\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:posList element');\n  }\n\n  return parseCoords(coords, options, childContext);\n}\n\nexport function parsePos(xml: any, options: ParseGMLOptions, context: ParseGMLContext): Position {\n  const childContext = createChildContext(xml, options, context);\n\n  const coords = textOf(xml);\n  if (!coords) {\n    throw new Error('invalid gml:pos element');\n  }\n\n  const points = parseCoords(coords, options, childContext);\n  if (points.length !== 1) {\n    throw new Error('gml:pos must have 1 point');\n  }\n  return points[0];\n}\n\nexport function parsePoint(xml: any, options: ParseGMLOptions, context: ParseGMLContext): number[] {\n  const childContext = createChildContext(xml, options, context);\n\n  // TODO AV: Parse other gml:Point options\n  const pos = findIn(xml, 'gml:pos');\n  if (!pos) {\n    throw new Error('invalid gml:Point element, expected a gml:pos subelement');\n  }\n  return parsePos(pos, options, childContext);\n}\n\nexport function parseLinearRingOrLineString(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  // or a LineStringSegment\n  const childContext = createChildContext(xml, options, context);\n\n  let points: Position[] = [];\n\n  const posList = findIn(xml, 'gml:posList');\n  if (posList) {\n    points = parsePosList(posList, options, childContext);\n  } else {\n    for (const [childName, childXML] of Object.entries(xml)) {\n      switch (childName) {\n        case 'gml:Point':\n          points.push(parsePoint(childXML, options, childContext));\n          break;\n        case 'gml:pos':\n          points.push(parsePos(childXML, options, childContext));\n          break;\n        default:\n          continue;\n      }\n    }\n  }\n\n  if (points.length === 0) {\n    throw new Error(`${xml.name} must have > 0 points`);\n  }\n  return points;\n}\n\nexport function parseCurveSegments(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const points: Position[] = [];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:LineStringSegment':\n        const points2 = parseLinearRingOrLineString(childXML, options, context);\n\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n\n        points.push(...points2);\n        break;\n      default:\n        continue;\n    }\n  }\n\n  if (points.length === 0) {\n    throw new Error('gml:Curve > gml:segments must have > 0 points');\n  }\n  return points;\n}\n\nexport function parseRing(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const childContext = createChildContext(xml, options, context);\n\n  const points: Position[] = [];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:curveMember':\n        let points2;\n\n        const lineString = findIn(childXML, 'gml:LineString');\n        if (lineString) {\n          points2 = parseLinearRingOrLineString(lineString, options, childContext);\n        } else {\n          const segments = findIn(childXML, 'gml:Curve', 'gml:segments');\n          if (!segments) {\n            throw new Error(`invalid ${childName} element`);\n          }\n\n          points2 = parseCurveSegments(segments, options, childContext);\n        }\n\n        // remove overlapping\n        const end = points[points.length - 1];\n        const start = points2[0];\n        if (end && start && deepStrictEqual(end, start)) {\n          points2.shift();\n        }\n\n        points.push(...points2);\n\n        break;\n    }\n  }\n\n  if (points.length < 4) {\n    throw new Error(`${xml.name} must have >= 4 points`);\n  }\n  return points;\n}\n\nexport function parseExteriorOrInterior(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[] {\n  const linearRing = findIn(xml, 'gml:LinearRing');\n  if (linearRing) {\n    return parseLinearRingOrLineString(linearRing, options, context);\n  }\n\n  const ring = findIn(xml, 'gml:Ring');\n  if (!ring) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  return parseRing(ring, options, context);\n}\n\nexport function parsePolygonOrRectangle(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][] {\n  // or PolygonPatch\n  const childContext = createChildContext(xml, options, context);\n\n  const exterior = findIn(xml, 'gml:exterior');\n  if (!exterior) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  const pointLists: Position[][] = [parseExteriorOrInterior(exterior, options, childContext)];\n\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:interior':\n        pointLists.push(parseExteriorOrInterior(childXML, options, childContext));\n        break;\n    }\n  }\n\n  return pointLists;\n}\n\nexport function parseSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const childContext = createChildContext(xml, options, context);\n\n  const patches = findIn(xml, 'gml:patches');\n  if (!patches) {\n    throw new Error(`invalid ${xml.name} element`);\n  }\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:PolygonPatch':\n      case 'gml:Rectangle':\n        polygons.push(parsePolygonOrRectangle(childXML, options, childContext));\n        break;\n\n      default:\n        continue;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n\n  return polygons;\n}\n\nexport function parseCompositeSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const childContext = createChildContext(xml, options, context);\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(xml)) {\n    switch (childName) {\n      case 'gml:surfaceMember':\n      case 'gml:surfaceMembers':\n        const [c2Name, c2Xml] = getFirstKeyValue(childXML);\n        switch (c2Name) {\n          case 'gml:Surface':\n            polygons.push(...parseSurface(c2Xml, options, childContext));\n            break;\n          case 'gml:Polygon':\n            polygons.push(parsePolygonOrRectangle(c2Xml, options, childContext));\n            break;\n        }\n        break;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n  return polygons;\n}\n\nexport function parseMultiSurface(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  let el = xml;\n\n  const surfaceMembers = findIn(xml, 'gml:LinearRing');\n  if (surfaceMembers) {\n    el = surfaceMembers;\n  }\n\n  const polygons: Position[][][] = [];\n  for (const [childName, childXML] of Object.entries(el)) {\n    switch (childName) {\n      case 'gml:Surface':\n        const polygons2 = parseSurface(childXML, options, context);\n        polygons.push(...polygons2);\n        break;\n      case 'gml:surfaceMember':\n        const polygons3 = parseSurfaceMember(childXML, options, context);\n        polygons.push(...polygons3);\n        break;\n\n      case 'gml:surfaceMembers':\n        const polygonXML = findIn(childXML, 'gml:Polygon');\n        for (const surfaceMemberXML of polygonXML as []) {\n          const polygons3 = parseSurfaceMember(surfaceMemberXML, options, context);\n          polygons.push(...polygons3);\n        }\n        break;\n    }\n  }\n\n  if (polygons.length === 0) {\n    throw new Error(`${xml.name} must have > 0 polygons`);\n  }\n\n  return polygons;\n}\n\nfunction parseSurfaceMember(\n  xml: any,\n  options: ParseGMLOptions,\n  context: ParseGMLContext\n): Position[][][] {\n  const [childName, childXml] = getFirstKeyValue(xml);\n  switch (childName) {\n    case 'gml:CompositeSurface':\n      return parseCompositeSurface(childXml, options, context);\n    case 'gml:Surface':\n      return parseSurface(childXml, options, context);\n    case 'gml:Polygon':\n      return [parsePolygonOrRectangle(childXml, options, context)];\n  }\n  throw new Error(`${childName} must have polygons`);\n}\n\n// Helpers\n\nfunction textOf(el: any): string {\n  if (typeof el !== 'string') {\n    throw new Error('expected string');\n  }\n  return el;\n}\n\nfunction findIn(root: any, ...tags: string[]): any {\n  let el = root;\n  for (const tag of tags) {\n    const child = el[tag];\n    if (!child) {\n      return null;\n    }\n    el = child;\n  }\n  return el;\n}\n\n/** @returns the first [key, value] pair in an object, or ['', null] if empty object */\nfunction getFirstKeyValue(object: any): [string, any] {\n  if (object && typeof object === 'object') {\n    for (const [key, value] of Object.entries(object)) {\n      return [key, value];\n    }\n  }\n  return ['', null];\n}\n\n/** A bit heavyweight for just tracking dimension? */\nfunction createChildContext(xml, options, context): ParseGMLContext {\n  const srsDimensionAttribute = xml.attributes && xml.attributes.srsDimension;\n\n  if (srsDimensionAttribute) {\n    const srsDimension = parseInt(srsDimensionAttribute);\n    if (Number.isNaN(srsDimension) || srsDimension <= 0) {\n      throw new Error(\n        `invalid srsDimension attribute value \"${srsDimensionAttribute}\", expected a positive integer`\n      );\n    }\n\n    const childContext = Object.create(context);\n    childContext.srsDimension = srsDimension;\n    return childContext;\n  }\n\n  return context;\n}\n"],"mappings":"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"}