{"version":3,"file":"lerc-loader.js","names":["Lerc","_interopRequireWildcard","require","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","VERSION","LERCLoader","id","name","module","version","worker","extensions","mimeTypes","options","wms","parse","arrayBuffer","parseLERC","exports","load","pixelBlock","decode","lerc","_typecheckLERCLoader"],"sources":["../../src/lerc-loader.ts"],"sourcesContent":["// loaders.gl, MIT license\n\nimport type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {LERCData} from './lib/parsers/lerc/lerc-types';\nimport * as Lerc from 'lerc';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nexport type LERCLoaderOptions = LoaderOptions & {\n  lerc?: {\n    /**\tThe number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position. */\n    inputOffset?: number;\n    /**\tIt is recommended to use the returned mask instead of setting this value. */\n    noDataValue?: number;\n    /**\t(ndepth LERC2 only) If true, returned depth values are pixel-interleaved. */\n    returnInterleaved?: boolean;\n  };\n};\n\n/**\n * Loader for the LERC raster format\n */\nexport const LERCLoader = {\n  id: 'lerc',\n  name: 'LERC',\n\n  module: 'wms',\n  version: VERSION,\n  worker: false,\n  extensions: ['lrc', 'lerc', 'lerc2', 'lerc1'],\n  mimeTypes: ['application/octet-stream'],\n  // test: ?,\n  options: {\n    wms: {}\n  },\n  parse: async (arrayBuffer: ArrayBuffer, options?: LERCLoaderOptions) =>\n    parseLERC(arrayBuffer, options)\n};\n\nasync function parseLERC(arrayBuffer: ArrayBuffer, options?: LERCLoaderOptions): Promise<LERCData> {\n  // Load the WASM library\n  await Lerc.load();\n  // Perform the decode\n  const pixelBlock = Lerc.decode(arrayBuffer, options?.lerc);\n  return pixelBlock;\n}\n\nexport const _typecheckLERCLoader: LoaderWithParser = LERCLoader;\n"],"mappings":";;;;;;AAIA,IAAAA,IAAA,GAAAC,uBAAA,CAAAC,OAAA;AAA6B,SAAAC,yBAAAC,WAAA,eAAAC,OAAA,kCAAAC,iBAAA,OAAAD,OAAA,QAAAE,gBAAA,OAAAF,OAAA,YAAAF,wBAAA,YAAAA,CAAAC,WAAA,WAAAA,WAAA,GAAAG,gBAAA,GAAAD,iBAAA,KAAAF,WAAA;AAAA,SAAAH,wBAAAO,GAAA,EAAAJ,WAAA,SAAAA,WAAA,IAAAI,GAAA,IAAAA,GAAA,CAAAC,UAAA,WAAAD,GAAA,QAAAA,GAAA,oBAAAA,GAAA,wBAAAA,GAAA,4BAAAE,OAAA,EAAAF,GAAA,UAAAG,KAAA,GAAAR,wBAAA,CAAAC,WAAA,OAAAO,KAAA,IAAAA,KAAA,CAAAC,GAAA,CAAAJ,GAAA,YAAAG,KAAA,CAAAE,GAAA,CAAAL,GAAA,SAAAM,MAAA,WAAAC,qBAAA,GAAAC,MAAA,CAAAC,cAAA,IAAAD,MAAA,CAAAE,wBAAA,WAAAC,GAAA,IAAAX,GAAA,QAAAW,GAAA,kBAAAH,MAAA,CAAAI,SAAA,CAAAC,cAAA,CAAAC,IAAA,CAAAd,GAAA,EAAAW,GAAA,SAAAI,IAAA,GAAAR,qBAAA,GAAAC,MAAA,CAAAE,wBAAA,CAAAV,GAAA,EAAAW,GAAA,cAAAI,IAAA,KAAAA,IAAA,CAAAV,GAAA,IAAAU,IAAA,CAAAC,GAAA,KAAAR,MAAA,CAAAC,cAAA,CAAAH,MAAA,EAAAK,GAAA,EAAAI,IAAA,YAAAT,MAAA,CAAAK,GAAA,IAAAX,GAAA,CAAAW,GAAA,SAAAL,MAAA,CAAAJ,OAAA,GAAAF,GAAA,MAAAG,KAAA,IAAAA,KAAA,CAAAa,GAAA,CAAAhB,GAAA,EAAAM,MAAA,YAAAA,MAAA;AAI7B,MAAMW,OAAO,GAAG,eAAkB,KAAK,WAAW,cAAiB,QAAQ;AAgBpE,MAAMC,UAAU,GAAG;EACxBC,EAAE,EAAE,MAAM;EACVC,IAAI,EAAE,MAAM;EAEZC,MAAM,EAAE,KAAK;EACbC,OAAO,EAAEL,OAAO;EAChBM,MAAM,EAAE,KAAK;EACbC,UAAU,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC;EAC7CC,SAAS,EAAE,CAAC,0BAA0B,CAAC;EAEvCC,OAAO,EAAE;IACPC,GAAG,EAAE,CAAC;EACR,CAAC;EACDC,KAAK,EAAE,MAAAA,CAAOC,WAAwB,EAAEH,OAA2B,KACjEI,SAAS,CAACD,WAAW,EAAEH,OAAO;AAClC,CAAC;AAACK,OAAA,CAAAb,UAAA,GAAAA,UAAA;AAEF,eAAeY,SAASA,CAACD,WAAwB,EAAEH,OAA2B,EAAqB;EAEjG,MAAMlC,IAAI,CAACwC,IAAI,CAAC,CAAC;EAEjB,MAAMC,UAAU,GAAGzC,IAAI,CAAC0C,MAAM,CAACL,WAAW,EAAEH,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAES,IAAI,CAAC;EAC1D,OAAOF,UAAU;AACnB;AAEO,MAAMG,oBAAsC,GAAGlB,UAAU;AAACa,OAAA,CAAAK,oBAAA,GAAAA,oBAAA"}